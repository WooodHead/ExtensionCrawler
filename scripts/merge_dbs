#!/usr/bin/env python3

import sqlite3
import sys
import os
import re
import json
import fnmatch

MAX_ATTACHED_DBS = 10


def merge_and_detach(con, currently_attached, mappings, columnnames):
    for db in currently_attached:
        for (fromtable, totable) in mappings.items():
            con.execute("INSERT INTO {} SELECT {} from {}.{};".format(
                totable, ",".join(columnnames[fromtable]), db, fromtable))

    con.commit()
    for db in currently_attached:
        con.execute("DETACH DATABASE {}".format(db))


def get_mappings_and_column_names(dbpath):
    with sqlite3.connect(dbpath) as con:
        create_strings = con.execute(
            """select name,sql from sqlite_master where type='table'"""
            """ and name NOT LIKE '%!_segments' escape '!'"""
            """ and name NOT LIKE '%!_segdir' escape '!'"""
            """ and name NOT LIKE '%!_docsize' escape '!'"""
            """ and name NOT LIKE '%!_stat' escape '!'"""
            """;""")
        mappings = {}
        columnnames = {}
        for (name, create_string, ) in create_strings:
            if re.match("^CREATE VIRTUAL TABLE ([^\s]+) using fts",
                        create_string):
                continue

            cnames = [
                name
                for (_, name, _, _, _, _) in con.execute(
                    "pragma table_info({});".format(name)).fetchall()
            ]
            if name.endswith("_content"):
                mappings[name] = name[:-len("_content")]
                columnnames[name] = cnames[1:]
            else:
                mappings[name] = name
                columnnames[name] = cnames

    return (mappings, columnnames)


def merge_schema(con, dbpath):
    con.execute("ATTACH DATABASE ? as schemadb;", (dbpath, ))
    create_strings = con.execute(
        """select sql from schemadb.sqlite_master where type='table'"""
        """ and name NOT LIKE '%!_segments' escape '!'"""
        """ and name NOT LIKE '%!_segdir' escape '!'"""
        """ and name NOT LIKE '%!_docsize' escape '!'"""
        """ and name NOT LIKE '%!_stat' escape '!'"""
        """ and name NOT LIKE '%!_content' escape '!'"""
        """;"""
    )

    for (create_string, ) in create_strings:
        print(create_string)
        con.execute(create_string)

    con.execute("DETACH DATABASE schemadb;")


def find(pattern, path):
    for root, dirs, files in os.walk(path):
        for name in files:
            if fnmatch.fnmatch(name, pattern):
                yield os.path.join(root, name)

def help():
    print("Usage: merge_dbs DBSPATH TODB")
    print("    DBSPATH   the folder containing the *.sqlite files")
    print("                (searched recursivly)")
    print("    TODB      the destination sqlite file")

def main(argv):
    if len(argv) != 2:
        help()
        sys.exit(1)
    dbspath, todb = argv[:2]

    print("Using sqlite3 version {}".format(sqlite3.sqlite_version))

    if os.path.isdir(dbspath):
        sqlitepaths = list(find("*.sqlite", dbspath))
    else:
        sqlitepaths = [dbspath]

    firstdb = sqlitepaths[0]
    mappings, columnnames = get_mappings_and_column_names(firstdb)
    print("Mappings:")
    print(json.dumps(mappings, indent=4))
    print("Column names:")
    print(json.dumps(columnnames, indent=4))

    with sqlite3.connect(todb) as con:
        if con.execute("SELECT COUNT(*) FROM sqlite_master;").fetchone()[
                0] == 0:
            print("Merging schema from {}".format(firstdb))
            merge_schema(con, firstdb)

        currently_attached = []
        for i, dbpath in enumerate(sqlitepaths):
            dbname = "db{}".format(i)
            print("Attaching {}".format(dbpath))
            con.execute("ATTACH DATABASE ? as ?", (dbpath, dbname))
            currently_attached += [dbname]
            if len(currently_attached) % MAX_ATTACHED_DBS == 0 or i + 1 == len(
                    sqlitepaths):
                merge_and_detach(con, currently_attached, mappings,
                                 columnnames)
                currently_attached = []
        con.commit()


if __name__ == "__main__":
    main(sys.argv[1:])
